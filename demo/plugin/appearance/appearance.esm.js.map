{"version":3,"file":"appearance.esm.js","sources":["../../../src/plugin/js/helpers.js","../../../src/plugin/js/functions/get-load-css.js","../../../src/plugin/js/functions/fix-list-item.js","../../../src/plugin/js/functions/get-appearance-arrays.js","../../../src/plugin/js/functions/show-hide-slide.js","../../../src/plugin/js/plugin.js","../../../src/plugin/js/functions/add-auto-animation.js","../../../src/plugin/js/functions/add-base-class.js","../../../src/plugin/js/functions/convert-to-spans.js","../../../src/plugin/js/functions/add-delay.js"],"sourcesContent":["/**\n * Check if a given string is valid JSON.\n * @param {string} str - The string to be checked.\n * @returns {boolean} `true` if the string is valid JSON, otherwise `false`.\n */\nexport const isJSON = str => {\n\ttry {\n\t\treturn (JSON.parse(str) && !!str);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n/**\n * Convert a NodeList into an array based on provided selectors.\n * @param {Element} container - The root element to begin querying.\n * @param {string} selectors - A string containing one or more CSS selectors separated by commas.\n * @returns {Element[]} Array of elements that match the given selectors.\n */\nexport const selectionArray = (container, selectors) => {\n\tlet selections = container.querySelectorAll(selectors);\n\tlet selectionarray = Array.prototype.slice.call(selections);\n\treturn selectionarray;\n};\n\n/**\n * Check if an element has child nodes that are `SECTION` elements.\n * @param {Object} param0 - Object with childNodes property.\n * @param {NodeListOf<ChildNode>} param0.childNodes - List of child nodes of the element.\n * @returns {boolean} `true` if the element contains `SECTION` child nodes, otherwise `false`.\n */\nexport const isStack = ({childNodes}) => {\n\tlet isStack = false;\n\tfor (let i = 0; i < childNodes.length; i++) {\n\t\tif (childNodes[i].tagName == \"SECTION\") {\n\t\t\tisStack = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn isStack;\n};\n\n/**\n * Copy data attributes from a source element to a target element with an optional exception.\n * @param {Object} param0 - Object with attributes property.\n * @param {NamedNodeMap} param0.attributes - Map of attributes of the source element.\n * @param {Element} target - Target element to copy attributes to.\n * @param {string} [not] - Optional attribute name to exclude from copying.\n */\nexport const copyDataAttributes = ({attributes}, target, not) => {\n\t[...attributes].filter(({nodeName}) => nodeName.includes('data')).forEach(({nodeName, nodeValue}) => {\n\t\tif ((not && nodeName !== not) || !not) {\n\t\t\ttarget.setAttribute(nodeName, nodeValue);\n\t\t}\n\t});\n};\n\n/**\n * Check if the given item is an object and not an array.\n * @param {*} item - The item to be checked.\n * @returns {boolean} `true` if the item is an object and not an array, otherwise `false`.\n */\nexport const isObject = (item) => {\n\treturn (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n/**\n * Deep merge multiple objects into a target object.\n * @param {Object} target - Target object to merge values into.\n * @param {...Object} sources - Source objects to merge from.\n * @returns {Object} The merged object.\n */\nexport const mergeDeep = (target, ...sources) => {\n\tif (!sources.length) return target;\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (isObject(source[key])) {\n\t\t\t\tif (!target[key]) Object.assign(target, { [key]: {} });\n\t\t\t\tmergeDeep(target[key], source[key]);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] });\n\t\t\t}\n\t\t}\n\t}\n\treturn mergeDeep(target, ...sources);\n}\n\n/**\n * Resolves the given Promise immediately using setTimeout.\n * @param {Function} resolve - The resolve function of a Promise.\n * @returns {number} The ID value of the timer that is set.\n */\nexport const doneLoading = (resolve) => {\n\treturn setTimeout(resolve, 0);\n}\n\n\n/**\n * Converts a JavaScript object or a JSON-formatted string to a JSON string.\n *\n * @param {Object|string} str - The input string or object to be converted to a JSON string.\n * @returns {string} The JSON string.\n */\nexport const toJSONString = (str) => {\n\tlet JSONString = ''\n\n\tif (typeof str === \"string\") str = str.replace(/[“”]/g,'\"').replace(/[‘’]/g,\"'\");\n\n\tif (isJSON(str)) {\n\t\tJSONString = str\n\t} else {\n\t\tif (typeof str === \"object\") {\n\t\t\tJSONString = JSON.stringify(str, null, 2)\n\t\t} else {\n\t\t\tJSONString = str.trim().replace(/'/g, '\"').charAt(0) === \"{\" ? str.trim().replace(/'/g, '\"') : `{${str.trim().replace(/'/g, '\"')}}`;\n\t\t}\n\t}\n\treturn JSONString;\n}\n\n\n/**\n * Dynamically loads a resource from the specified URL and calls a callback function when it's loaded.\n * Will not load the resource if it has already been loaded.\n *\n * @param {string} url - The URL of the resource to load.\n * @param {string} type - The type of resource to load.\n * @param {Function} callback - A callback function to be called when the resource is loaded.\n */\n\nexport const loadResource = (url, type, callback) => {\n\tlet head = document.querySelector('head');\n\tlet resource;\n\tlet alreadyExists = false;\n\n\tif (type === 'script') {\n\t\tif (!document.querySelector(`script[src=\"${url}\"]`)) {\n\t\t\tresource = document.createElement('script');\n\t\t\tresource.type = 'text/javascript';\n\t\t\tresource.src = url;\n\t\t} else { alreadyExists = true }\n\n\t} else if (type === 'stylesheet') {\n\n\t\tif (!document.querySelector(`link[href=\"${url}\"]`)) {\n\t\t\tresource = document.createElement('link');\n\t\t\tresource.rel = 'stylesheet';\n\t\t\tresource.href = url;\n\t\t} else { alreadyExists = true }\n\t}\n\n\tif (!alreadyExists) {\n\t\tconst finish = () => {\n\t\t\tif (typeof callback === 'function') {\n\t\t\tcallback.call();\n\t\t\tcallback = null;\n\t\t\t}\n\t\t};\n\t\tresource.onload = finish;\n\t\tresource.onreadystatechange = function () {\n\t\t\tif (this.readyState === 'loaded') {\n\t\t\t\tfinish();\n\t\t\t}\n\t\t};\n\t\thead.appendChild(resource);\n\t}\n}\n\n\n/**\n * Retrieves the path of a JavaScript file based on its filename.\n *\n * @param {string} fileName - The filename of the script.\n * @returns {string} The path to the plugin's location.\n */\nexport const pluginPath = (fileName) => {\n\tlet path;\n\tlet pluginScript = document.querySelector(`script[src$=\"${fileName}\"]`);\n\tif (pluginScript) {\n\t\tpath = pluginScript.getAttribute(\"src\").slice(0, -1 * (fileName.length));\n\t} else {\n\t\tpath = import.meta.url.slice(0, import.meta.url.lastIndexOf('/') + 1);\n\t}\n\treturn path;\n}\n\n\n/**\n * Check if element 'a' appears before element 'b' in the DOM tree.\n *\n * @param {HTMLElement} a - The first HTML element to compare.\n * @param {HTMLElement} b - The second HTML element to compare.\n * @returns {boolean|undefined} - Returns `true` if element 'a' appears before element 'b', `false` if 'b' appears before 'a', and `undefined` if the elements have no relative position in the DOM tree.\n */\nexport const isBefore = (a, b) => {\n    var all = document.getElementsByTagName('*');\n\n    for (var i = 0; i < all.length; ++i) {\n        if (all[i] === a) {\n            return true;\n        } else if (all[i] === b) {\n            return false;\n        }\n    }\n    // If the elements have no relative position in the DOM tree\n    return undefined;\n};\n\n\n/**\n * Check the number of occurrences of a specific element in an array.\n *\n * @param {Array} array - The array in which occurrences are to be counted.\n * @param {*} element - The element to be counted within the array.\n * @returns {number} - The count of occurrences of the specified element in the array.\n */\nexport const checkOccurrence = (array, element) => {\n    let counter = 0;\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] == element) {\n            counter++;\n        }\n    }\n    return counter;\n};\n\n\n/**\n * Create an HTML element from a string of HTML.\n *\n * @param {string} thehtml - The string of HTML to be converted into an HTML element.\n * @returns {HTMLElement | null} - The HTML element created from the provided HTML string. Returns `null` if the element couldn't be created.\n */\nexport const createNode = (thehtml) => {\n    const fragment = document.createRange().createContextualFragment(thehtml);\n    return fragment.firstElementChild;\n};\n\n\n/**\n * Gets the index of the given DOM element within its parent's children.\n * @param {HTMLElement} elm - The target element.\n * @returns {number} - The index of the element within its parent's children.\n */\nexport const getNodeIndex = (elm) => [...elm.parentNode.children].indexOf(elm);\n\n\nexport const debugLog = (options, text) => {\n\tif (options.debug) console.log(text);\n}\n\n","import { loadResource } from '../helpers';\nimport { pluginPath } from '../helpers';\n\n/**\n * Retrieves and loads CSS stylesheets based on the provided options and ES5 filename.\n *\n * @param {Object} options - Configuration options for loading CSS.\n * @param {string} fileName - The filename of the script.\n */\n\nexport const getAndLoadCSS = (options, fileName) => {\n\tlet thePath = pluginPath(fileName);\n\tlet pluginBaseName = fileName.replace(/\\.[^/.]+$/, \"\");\n\n\tif (options.cssautoload) {\n\t\tlet AppearanceStylePath = options.csspath.appearance ? options.csspath.appearance : null || `${thePath}${pluginBaseName}.css` || `plugin/${pluginBaseName}/${pluginBaseName}.css`\n\t\tlet AnimateCSSPath = !options.compatibility ? options.animatecsspath.link : options.animatecsspath.compat;\n\t\n\t\tif (options.debug) {\n\t\t\tconsole.log(`Paths:`);\n\t\t\tconsole.log(`  - Plugin path = ${thePath}`);\n\t\t\tconsole.log(`  - Appearance CSS path = ${AppearanceStylePath}`);\n\t\t\tconsole.log(`  - AnimateCSS CSS path = ${AnimateCSSPath}`);\n\t\t}\n\t\n\t\tloadResource(AnimateCSSPath, 'stylesheet', function () {\n\t\t\tloadResource(AppearanceStylePath, 'stylesheet');\n\t\t});\n\t}\n}","import { copyDataAttributes } from '../helpers';\n\n/**\n * Hoist a list item's appearance to its parent element's appearance.\n *\n * @param {HTMLElement} from - The list item element.\n * @returns {undefined}\n */\nconst hoistAppearance = (from, baseclass) => {\n\tlet to = from.parentNode;\n\tif (!to) return;\n  \n\tfor (const sibling of to.children) {\n\t  if (sibling !== from && sibling.dataset.appearParent) return;\n\t}\n  \n\tto.classList = from.classList;\n\tcopyDataAttributes(from, to, \"data-appear-parent\");\n\tto.innerHTML = from.innerHTML;\n\tto.classList.add(baseclass);\n};\n\n\n/**\n * Fix list items that were changed by Quarto.\n *\n * This function is designed for use with Quarto and handles the conversion of list items\n * with Appearance classes to their parent elements when a manual attribute is present.\n * It also provides automatic conversion for list items that directly contain spans, which\n * is related to Quarto's wrapping of list content in a span.\n *\n * @param {HTMLElement} appearance - The list item element whose appearance will be converted.\n * @param {Object} options - An options object that controls the conversion behavior.\n * @param {boolean} options.appearparents - If `true`, automatic conversion of list items with spans is enabled.\n * @returns {undefined}\n */\nexport const fixListItem = (appearance, options, names) => {\n\n\tlet baseclass = names.baseclass\n\tif (appearance.hasAttribute(\"data-appear-parent\")) {\n\t\thoistAppearance(appearance, baseclass);\n\t}\n\n\tif (options.appearparents) {\n\t\tif (appearance.parentNode && appearance.parentNode.tagName) {\n\t\t\tif (appearance.tagName == \"SPAN\" && appearance.parentNode.tagName == \"LI\") {\n\t\t\t\tlet spanLength = String(appearance.outerHTML).length;\n\t\t\t\tlet liContentLength = String(appearance.parentNode.innerHTML).length;\n\t\t\t\tif (spanLength == liContentLength) {\n\t\t\t\t\thoistAppearance(appearance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Selects elements with a specified class that are not nested inside an element with another specified class.\n * @param {string} targetClass - The class name to select elements.\n * @param {string} excludeClass - The class name to exclude elements nested inside it.\n * @param {Element} el - The element to find the target elements in.\n * @returns {Element[]} - Array of selected elements.\n */\nconst elemsNotInClass = (targetClass, excludeClass, el) => \n    Array.from(el.querySelectorAll(`.${targetClass}`))\n        .filter(s => !s.closest(`.${excludeClass}`));\n\n/**\n * Selects elements with a specified class that are nested inside an element with another specified class.\n * @param {string} targetClass - The class name to select elements.\n * @param {string} parentClass - The class name of the parent to find elements in.\n * @param {Element} el - The element to find the target elements in.\n * @returns {Element[]} - Array of selected elements.\n */\nconst elemsInClass = (targetClass, parentClass, el) =>\n    Array.from(el.querySelectorAll(`.${targetClass}`))\n        .filter(s => s.closest(`.${parentClass}`) === el);\n\n/**\n * Extracts groups of elements with a specified class from the provided section element.\n * Groups are formed based on nesting inside elements with another specified class.\n * @param {Element} section - The section to extract data from.\n * @returns {Element[][]} - Nested arrays of selected elements.\n */\n\n\n/**\n * Extracts groups of elements with a specified class from the provided section element.\n * Groups are formed based on nesting inside elements with another specified class.\n * @param {Element} section - The section to extract data from.\n * @param {string} targetClass - The class name to select elements.\n * @param {string} groupClass - The class name of the parent to find elements in.\n * @returns {Element[][]} - Nested arrays of selected elements.\n */\nexport const getAppearanceArrays = (section, targetClass, groupClass) => {\n    const result = [\n        elemsNotInClass(targetClass, groupClass, section), \n        ...Array.from(section.querySelectorAll(`.${groupClass}`))\n            .map(frag => elemsInClass(targetClass, groupClass, frag))\n    ];\n\n\tif (result.some(group => group.length > 0)) {\n        return result;\n    } else {\n\t\treturn false;\n\t}\n};\n","/**\n * Derives slide from and to from the event object.\n *\n * @param {Object} event - The event object containing slide transition details.\n * @returns {Object} - An object containing references to the \"from\" and \"to\" slides.\n */\nconst fromTo = (event) => {\n\tlet slides = {};\n\tslides.from = event.fromSlide || event.previousSlide || null;\n\tslides.to = event.toSlide || event.currentSlide || null;\n\treturn slides;\n};\n\n/**\n * A function that determines the appearance event for a given slide.\n *\n * This function checks the `data-appearevent` attribute of the slide and the `options.appearevent` parameter.\n * If `data-appearevent` is set to \"auto\", it is converted to \"autoanimate\". If `options.appearevent` is \"auto\", it is also converted to \"autoanimate\".\n * The function returns the appearance event, prioritizing `data-appearevent` over `options.appearevent`.\n *\n * @param {HTMLElement} toSlide - The slide for which the appearance event is determined.\n * @param {Object} options - An object containing options for the appearance event.\n * @param {string} options.appearevent - The appearance event option provided in the `options` object.\n *\n * @returns {string} - The determined appearance event for the slide, either from `data-appearevent` or `options.appearevent`.\n */\nconst slideAppearevent = (toSlide, options) => {\n\n\tif (toSlide.dataset.appearevent && toSlide.dataset.appearevent === \"auto\" ) {\n\t\ttoSlide.dataset.appearevent = \"autoanimate\"\n\t}\n\tif (options.appearevent == \"auto\") {options.appearevent = \"autoanimate\"}\n\treturn toSlide.dataset.appearevent ? toSlide.dataset.appearevent : options.appearevent;\n};\n\n/**\n * Remove the 'data-appearance-can-start' attribute from the 'from' slide if the 'hideagain' option is enabled.\n *\n * @param {HTMLElement} slides - The container element for the slides.\n * @param {Object} options - An object containing configuration options.\n * @param {boolean} options.hideagain - A flag indicating whether to remove the attribute when 'hideagain' is true.\n */\nconst removeStartAttribute = (slides, options) => {\n\tif (options.hideagain) {\n\t\tif (slides.from && slides.from.dataset.appearanceCanStart ) {\n\t\t\tslides.from.removeAttribute('data-appearance-can-start');\n\t\t}\n\t}\n};\n\n\n/**\n * Turn off slide appearances when transitioning from one slide to another if the 'hideagain' option is enabled.\n *\n * @param {HTMLElement} slides - The container element for the slides.\n * @param {Object} options - An object containing configuration options.\n * @param {string} names.animatecss - The CSS selector for animated elements.\n */\nconst turnOffSlideAppearances = (slides, options, names) => {\n\tif (options.hideagain) {\n\t\tif (slides && slides.from) {\n\n\t\t\t// Remove animationended class from animated elements when moving away from that slide\n\t\t\tlet fromAppearances = slides.from.querySelectorAll(names.animatecss);\n\t\t\tif (fromAppearances) {\n\t\t\t\tfromAppearances.forEach( appearance => {\n\t\t\t\t\tappearance.classList.remove('animationended');\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Remove visible class from fragments when moving away from that slide\n\t\t\tlet fromFragments = slides.from.querySelectorAll(`.fragment.visible`);\n\t\t\tif (fromFragments) {\n\t\t\t\tfromFragments.forEach(fragment => {\n\t\t\t\t\tfragment.classList.remove('visible');\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/**\n * Handles the showing and hiding of slides based on the provided event and options.\n *\n * @param {Object} event - The event object containing slide transition details.\n * @param {Object} options - An object containing configurations for slide appearance management.\n */\nexport const showHideSlide = (event, options, names, vars) => {\n\n\tlet view = vars.deck.getConfig().view;\n\tlet isScroll = vars.viewport.classList.contains(\"reveal-scroll\");\n\tlet etype = event.type;\n\tlet slides = fromTo(event);\n\n\tif (slides.to) {\n\n\t\tif (etype == \"ready\") {\n\t\t\tslides.to.dataset.appearanceCanStart = true;\n\t\t}\n\n\t\tlet appearevent = slideAppearevent(slides.to, options)\n\n\t\tif (etype == appearevent || (etype == \"slidetransitionend\" && appearevent == \"autoanimate\")) {\n\t\t\tslides.to.dataset.appearanceCanStart = true;\n\t\t}\n\n\t\t// Add scroll mode compatibility, does not have a slidetransitionend event yet\n\t\tif (isScroll && etype == 'slidechanged' ) {\n\n\t\t\tremoveStartAttribute(slides, options);\n\t\t\tturnOffSlideAppearances(slides, options, names);\n\n\t\t\t// Add delay to allow for scroll animation to finish\n\t\t\tsetTimeout(() => {\n\t\t\t\tslides.to.dataset.appearanceCanStart = true;\n\t\t\t}, options.delay)\n\t\t}\n\n\n\t\tif (etype == \"slidetransitionend\" ) {\n\n\t\t\tremoveStartAttribute(slides, options);\n\t\t\tturnOffSlideAppearances(slides, options, names);\n\t\t}\n\t\t\n\t\tif (etype == 'slidechanged' && document.body.dataset.exitoverview) {\n\t\t\tremoveStartAttribute(slides, options);\n\t\t\tslides.to.dataset.appearanceCanStart = true;\n\n\t\t} else if (etype == 'overviewhidden' ) {\n\n\t\t\tdocument.body.dataset.exitoverview = true;\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.body.removeAttribute('data-exitoverview')\n\t\t\t}, 500)\n\n\t\t\tif (event.currentSlide ) {\n\t\t\t\tremoveStartAttribute(slides, options);\n\t\t\t\tslides.to.dataset.appearanceCanStart = true;\n\t\t\t}\n\t\t}\n\t}\n}","import { debugLog, mergeDeep, doneLoading, isStack } from './helpers';\n\nimport {getAndLoadCSS} from './functions/get-load-css.js';\nimport {addAutoAnimation} from './functions/add-auto-animation.js';\nimport {fixListItem} from './functions/fix-list-item';\nimport {addBaseClass} from './functions/add-base-class.js';\nimport {addDelay} from './functions/add-delay.js';\nimport {getAppearanceArrays} from './functions/get-appearance-arrays.js';\nimport {convertToSpans} from './functions/convert-to-spans';\nimport {showHideSlide} from './functions/show-hide-slide.js';\n\n\nconst Plugin = () => {\n\n\tconst vars = {};\n\tvars.names = {};\n\tlet options = {};\n\n\t/**\n\t* Prepare the plugin to find Appearance elements\n\t* @param {Object} vars - The variables to be prepared.\n\t* @param {Object} names - The names to be prepared.\n\t* @param {Function} resolve - The callback function to be called when preparation is complete.\n\t* @throws {Error} Throws an error if the 'options' object is not defined.\n\t*/\n\tconst prepare = (options, vars, resolve) => {\n\n\t\tdebugLog(options, \"-------------   Preloading   -------------\");\n\n\t\tlet names = vars.names;\n\n\t\tgetAndLoadCSS(options, names.es5Filename);\n\n\t\tif (options.compatibility) {\n\t\t\tnames.animatecss = '.backInDown, .backInLeft, .backInRight, .backInUp, .bounceIn, .bounceInDown, .bounceInLeft, .bounceInRight, .bounceInUp, .fadeIn, .fadeInDown, .fadeInDownBig, .fadeInLeft, .fadeInLeftBig, .fadeInRight, .fadeInRightBig, .fadeInUp, .fadeInUpBig, .fadeInTopLeft, .fadeInTopRight, .fadeInBottomLeft, .fadeInBottomRight, .flipInX, .flipInY, .lightSpeedInRight, .lightSpeedInLeft, .rotateIn, .rotateInDownLeft, .rotateInDownRight, .rotateInUpLeft, .rotateInUpRight, .jackInTheBox, .rollIn, .zoomIn, .zoomInDown, .zoomInLeft, .zoomInRight, .zoomInUp, .slideInDown, .slideInLeft, .slideInRight, .slideInUp, .skidLeft, .skidLeftBig, .skidRight, .skidRightBig, .shrinkIn, .shrinkInBlur';\n\t\t\tnames.baseclass = options.compatibilitybaseclass\n\t\t}\n\n\t\tvars.appearances = Array.from(vars.slides.querySelectorAll(names.animatecss));\n\n\t\t// Go through each section to see if there are any (auto) selectors that need animation classes\n\t\tvars.regularSections.forEach(theSection => addAutoAnimation(theSection, options, vars));\n\n\t\tvars.appearances.forEach((theAppearance, index) => {\n\t\t\t// Fix any list item where the Appearance classes were moved to the span (Quarto does this)\n\t\t\tfixListItem(theAppearance, options, names);\n\n\t\t\t// Go through each appearance element and add the baseclass if it doesn't have it\n\t\t\taddBaseClass(theAppearance, names);\n\n\t\t\tif (theAppearance.hasAttribute('data-split')) {\n\t\t\t\tconvertToSpans(theAppearance, theAppearance.dataset.split);\n\t\t\t}\n\t\t});\n\n\t\tvars.regularSections.forEach((theSection, index) => {\n\t\t\t// Get all the Appearances in the section as separate arrays per delay loop\n\t\t\tlet appearanceArrays = getAppearanceArrays(theSection, names.baseclass, names.fragmentClass);\n\n\t\t\tif (appearanceArrays) {\n\t\t\t\tappearanceArrays.forEach((appearanceArray) => {\n\t\t\t\t\t// Add the delays to each appearance in the array\n\t\t\t\t\taddDelay(appearanceArray, options, names)\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\n\t\tdoneLoading(resolve);\n\t}\n\n\t/**\n\t* The main function of the plugin\n\t* @param {object} deck - The deck object\n\t* @param {object} options - The options object\n\t* @param {string} es5Filename - The name of the file that will be used\n\t*/\n\tconst Appear = (deck, options, es5Filename) => {\n\n\t\tlet names = vars.names;\n\n\t\t// Set up names\n\t\tnames.baseclass = options.baseclass;\n\t\tnames.compatibilitybaseclass = options.compatibilitybaseclass;\n\t\tnames.fragmentSelector = \".fragment\";\n\t\tnames.fragmentClass = \"fragment\";\n\t\tnames.speedClasses = ['slower', 'slow', 'fast', 'faster'];\n\t\tnames.speedClasses.push(...names.speedClasses.map(speed => `animate__${speed}`));\n\t\tnames.animatecss = '[class^=\"animate__\"],[class*=\" animate__\"]';\n\t\tnames.es5Filename = es5Filename;\n\t\tnames.eventnames = ['ready', 'slidechanged', 'slidetransitionend', 'autoanimate', 'overviewhidden'];\n\t\n\t\t// Set up variables\n\t\tvars.deck = deck;\n\t\tvars.dom = deck.getRevealElement();\n\t\tvars.viewport = deck.getViewportElement();\n\t\tvars.slides = deck.getSlidesElement();\n\n\t\tvars.sections = vars.slides.querySelectorAll('section');\n\t\tvars.fragments = vars.slides.querySelectorAll(names.fragmentSelector);\n\t\tvars.regularSections = Array.from(vars.sections).filter( section => !isStack(section));\n\n\t\t// Check if Speaker view window\n\t\tif( /receiver/i.test( window.location.search ) ) vars.viewport.classList.add('sv');\n\n\t\tnames.eventnames.forEach( (eventname) => deck.on( eventname, event => { showHideSlide(event, options, names, vars) } ) );\n\n\t\tvars.viewport.addEventListener(\"animationend\", (event) => {\n\t\t\tevent.target.classList.add('animationended');\n\t\t});\n\t\tvars.viewport.addEventListener(\"fragmenthidden\", (event) => {\n\t\t\tevent.fragment.classList.remove('animationended');\n\t\t\tevent.fragment.querySelectorAll('.animationended').forEach(el => {\n\t\t\t\tel.classList.remove('animationended');\n\t\t\t});\n\t\t});\n\n\t\treturn new Promise(resolve => {\n\t\t\tprepare(options, vars, resolve);\n\t\t\tdebugLog(options, \"----------   Done preloading   ----------\");\n\t\t});\n\t};\n\n\n\t/**\n\t* Initialize the plugin\n\t* @param {object} deck - The deck object\n\t*/\n\tconst init = (deck) => {\n\n\t\tlet defaultOptions = {\n\t\t\tbaseclass: 'animate__animated',\n\t\t\thideagain: true,\n\t\t\tdelay: 300,\n\t\t\tdebug: false,\n\t\t\tappearevent: 'slidetransitionend',\n\t\t\tautoappear: false,\n\t\t\tautoelements: false,\n\t\t\tappearparents: false,\n\t\t\tcssautoload: true,\n\t\t\tcsspath: '',\n\t\t\tanimatecsspath: {\n\t\t\t\tlink : 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css',\n\t\t\t\tcompat : 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.compat.css',\n\t\t\t},\n\t\t\tcompatibility: false,\n\t\t\tcompatibilitybaseclass: 'animated'\n\t\t};\n\n\t\toptions = mergeDeep(defaultOptions, deck.getConfig().appearance || {});\n\n\t\treturn Appear(deck, options, \"appearance.js\");\n\t};\n\n\treturn { id: 'appearance', init: init };\n};\n\nexport default Plugin;","import { toJSONString } from '../helpers';\n\n\n/**\n * Adds automatic animations to elements within a section based on specified criteria.\n *\n * This function examines the provided section for attributes and options to determine\n * which classes should be added to its elements to enable automatic animations.\n *\n * @param {HTMLElement} section - The section element to which automatic animations will be applied.\n * @param {Object} options - The existing user options object\n * @param {Object} vars - The existing vars object\n * @returns {undefined}\n */\nexport const addAutoAnimation = (section, options, vars) => {\n\n\tlet sectionAutoSelectors = null;\n\n\tif (section.hasAttribute(\"data-autoappear\")) {\n\n\t\tlet sectDataAppear = section.dataset.autoappear;\n\n\t\tif (sectDataAppear == \"auto\" || sectDataAppear == \"\" || sectDataAppear.length < 1 || sectDataAppear == \"true\") {\n\t\t\t// This section should get the global autoappear classes on its objects\n\t\t\tsectionAutoSelectors = options.autoelements ? options.autoelements : null;\n\t\t} else {\n\t\t\t// This section should get the local autoappear classes on its objects\n\t\t\tsectionAutoSelectors = sectDataAppear;\n\t\t}\n\n\t} else if ( options.autoappear && options.autoelements ) {\n\t\t// This section should get the global autoappear classes on its objects\n\t\tsectionAutoSelectors = options.autoelements;\n\t}\n\n\tif (sectionAutoSelectors) {\n\n\t\tlet elementsToAnimate = JSON.parse(toJSONString(sectionAutoSelectors));\n\n\t\tObject.entries(elementsToAnimate).forEach(([selector, assignables]) => {\n\n\n\t\t\t// Exclude the elements from vars.appearances\n\t\t\tlet elements = Array.from(section.querySelectorAll(selector)).filter( element => !vars.appearances.includes(element) );\n\n\t\t\tif (elements.length) {\n\n\t\t\t\telements.forEach((element) => {\n\n\t\t\t\t\tvars.appearances.push(element)\n\n\t\t\t\t\tlet newClasses = [], newDelay = null, speedClass = false, elementSplit = null, containerDelay = null;\n\n\t\t\t\t\tif (Array.isArray(assignables)) {\n\n\t\t\t\t\t\tnewClasses = assignables[0].split(/[ ,]+/);\n\t\t\t\t\t\tnewDelay = assignables[1];\n\n\t\t\t\t\t} else if (typeof assignables == \"string\"){\n\n\t\t\t\t\t\tnewClasses = assignables.split(/[ ,]+/);\n\n\t\t\t\t\t} else if (assignables.constructor === Object) {\n\n\t\t\t\t\t\tif (assignables.class || assignables.animation) {\n\t\t\t\t\t\t\tlet animationClass = assignables.animation ? assignables.animation : assignables.class;\n\t\t\t\t\t\t\tnewClasses = animationClass.split(/[ ,]+/);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (assignables.speed) {\n\t\t\t\t\t\t\tspeedClass = String(assignables.speed);\n\t\t\t\t\t\t\tif (!speedClass.includes(\"animate__\")) {\n\t\t\t\t\t\t\t\tspeedClass = `animate__${speedClass}`\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (assignables.delay) {\n\t\t\t\t\t\t\tnewDelay = String(assignables.delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (assignables.split) {\n\t\t\t\t\t\t\telementSplit = String(assignables.split);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (assignables[\"container-delay\"]) {\n\t\t\t\t\t\t\tcontainerDelay = String(assignables[\"container-delay\"]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telement.classList.add(...newClasses);\n\t\t\t\t\tif (speedClass) { element.classList.add(speedClass)}\n\n\t\t\t\t\tif (newDelay) {\n\t\t\t\t\t\tif (!element.dataset.delay) {\n\t\t\t\t\t\t\telement.dataset.delay = newDelay\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (elementSplit) {element.dataset.split = elementSplit};\n\t\t\t\t\tif (containerDelay) {element.dataset.containerDelay = containerDelay};\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * Adds a base class to an HTML element if it doesn't already have it.\n *\n * This function checks if the specified HTML element has the specified base class,\n * and if not, it adds the base class to the element's class list.\n *\n * @param {HTMLElement} appearance - The HTML element to which the base class should be added.\n * @param {Object} names - The existing 'names' object\n * @returns {undefined}\n */\n\nexport const addBaseClass = (appearance, names) => {\n\tif (!appearance.classList.contains(names.baseclass)) {\n\t\tappearance.classList.add(names.baseclass);\n\t}\n\tif (appearance.classList.contains(names.fragmentClass)) {\n\t\tappearance.classList.add('custom');\n\t}\n}\n","export const convertToSpans = (parent, kind) => {\n\n\tlet splitElements = false;\n\tlet joinChar = ' ';\n\n\tif (kind == \"words\") {\n\t\tsplitElements = parent.textContent.trim().split(/\\s+/);\n\t\t\n\t} else if (kind == \"letters\") {\n\t\tsplitElements = parent.textContent.trim().split('');\n\t\tjoinChar = '';\n\t}\n\n\tif (splitElements) {\n\t\tconst parentAnimateClasses = Array.from(parent.classList).filter(className => className.startsWith('animate__'));\n\t\n\t\tconst newHtml = splitElements.map((element, index) => {\n\t\t\tconst span = document.createElement('span');\n\t\t\tspan.textContent = element;\n\t\t\tif (element == \" \") {span.textContent = \"\\u00A0\"}\n\t\n\t\t\tif (parent.dataset.delay && index !== 0) {\n\t\t\t\tspan.dataset.delay = parent.dataset.delay\n\t\t\t}\n\n\t\t\tif (parent.dataset.containerDelay && index === 0) {\n\t\t\t\tspan.dataset.delay = parent.dataset.containerDelay\n\t\t\t}\n\t\t\tparent.classList.add('wordchargroup');\n\t\n\t\t\tparent.classList.forEach(className => className.startsWith('animate__') && span.classList.add(className));\n\t\t\treturn span.outerHTML;\n\t\t\t\n\t\t}).join(joinChar);\n\t\n\t\tparentAnimateClasses.forEach(className => parent.classList.remove(className));\n\t\tparent.removeAttribute('data-delay');\n\t\tparent.removeAttribute('data-split');\n\t\tparent.removeAttribute('data-container-delay');\n\t\n\t\tparent.innerHTML = newHtml;\n\t}\n\n\n};","export const addDelay = (appearanceArray, options, names) => {\n\n    let delay = 0;\n    appearanceArray.forEach((appearance, index) => {\n\n        if ((index == 0 && appearance.dataset.delay) || index !=0) {\n\n            let elementDelay = options.delay;\n\n            if (appearance.dataset && appearance.dataset.delay) {\n                elementDelay = parseInt(appearance.dataset.delay);\n            }\n\n            delay = delay + elementDelay;\n\n            appearance.style.setProperty('animation-delay', delay + \"ms\");\n            appearance.removeAttribute('data-delay');\n        }\n\n    })\n\n}\n"],"names":["isObject","item","Array","isArray","mergeDeep","target","sources","length","source","shift","key","Object","assign","toJSONString","str","JSONString","replace","JSON","parse","e","isJSON","stringify","trim","charAt","loadResource","url","type","callback","resource","head","document","querySelector","alreadyExists","createElement","rel","href","finish","call","onload","onreadystatechange","this","readyState","appendChild","debugLog","options","text","debug","console","log","getAndLoadCSS","fileName","thePath","path","pluginScript","getAttribute","slice","lastIndexOf","pluginPath","pluginBaseName","cssautoload","AppearanceStylePath","csspath","appearance","AnimateCSSPath","compatibility","animatecsspath","compat","link","hoistAppearance","from","baseclass","to","parentNode","sibling","children","dataset","appearParent","classList","copyDataAttributes","attributes","not","filter","nodeName","includes","forEach","nodeValue","setAttribute","innerHTML","add","elemsNotInClass","targetClass","excludeClass","el","querySelectorAll","s","closest","getAppearanceArrays","section","groupClass","result","map","frag","elemsInClass","parentClass","some","group","removeStartAttribute","slides","hideagain","appearanceCanStart","removeAttribute","turnOffSlideAppearances","names","fromAppearances","animatecss","remove","fromFragments","fragment","Plugin","vars","prepare","resolve","es5Filename","compatibilitybaseclass","appearances","regularSections","theSection","addAutoAnimation","sectionAutoSelectors","hasAttribute","sectDataAppear","autoappear","autoelements","elementsToAnimate","entries","selector","assignables","elements","element","push","newClasses","newDelay","speedClass","elementSplit","containerDelay","split","constructor","class","animation","speed","String","delay","theAppearance","index","fixListItem","appearparents","tagName","outerHTML","addBaseClass","contains","fragmentClass","convertToSpans","parent","kind","splitElements","joinChar","textContent","parentAnimateClasses","className","startsWith","newHtml","span","join","appearanceArrays","appearanceArray","addDelay","elementDelay","parseInt","style","setProperty","setTimeout","doneLoading","Appear","deck","fragmentSelector","speedClasses","eventnames","dom","getRevealElement","viewport","getViewportElement","getSlidesElement","sections","fragments","isStack","childNodes","i","test","window","location","search","eventname","on","event","showHideSlide","getConfig","view","isScroll","etype","fromSlide","previousSlide","toSlide","currentSlide","fromTo","appearevent","slideAppearevent","body","exitoverview","addEventListener","Promise","id","init"],"mappings":"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"}